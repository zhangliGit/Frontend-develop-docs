# javascript核心概念

## javascript引擎

+ javascript引擎用来编译和运行javascript代码

+ javascript引擎先把源代码编译成ast（抽象语法书），然后在通过jit(即时编译)转化为本地机器码执行，此过程中会对语法进行优化

+ javascript是动态编译，只有在函数调用时才会编译成本地代码（机器码），这样就提高了响应时间减少了时间开销

## 执行上下文

**<p class="tip-color">概念</p>**

> js的执行上下文可以理解为当前代码的执行环境，在执行js程序时，每遇到一段js代码，都会创建一个对应的执行上下文，js中可执行代码可分为三种：全局代码，函数代码，eval代码，所有一段js代码必定会产生多个执行上下文，javascript引擎是以堆栈的形式来对其进行管理的，也就是常说的调用栈，栈底是全局执行上下文，栈顶是当前正在执行的上下文

```js
const global = 'globalStack'
function threeStack() {
    const three = 'threeStack'
    function twoStack() {
        const two = 'twoStack'
        eval(console.log('oneStack'))
    }
    twoStack()
}
```

如下代码的调用栈中执行上下文的顺序从底向上依次是 globalStack => threeStack => twoStack => oneStack

**<p class="tip-color">特性</p>**

+ js引擎是单线程

+ 同步执行，调用栈中只有顶层的执行上下文处在执行中，其他的上下文需要等待

+ 全局上下文只有唯一一个，它在浏览器关闭时出栈

+ 函数的执行上下文个数没有限制

+ 每次某个函数被调用，就会有个执行上下文被创建，即使是调用自身的函数，也是如此

**<p class="tip-color">生命周期</p>**

> 第一步：创建阶段

每当js引擎在执行一段可执行代码时，都会先进入创建阶段，该阶段会分别创建变量对象（用于存储在执行上下文中定义的变量和函数声明，此时变量对象不能被访问），建立作用域链以及确定this的执行

> 第二部：执行阶段

当变量对象，作用域链和this指向都建立之后，执行上下文就会进入到执行阶段，在该阶段变量对象就会变为活动对象，对象中的变量和函数声明就可以被访问到

> 第三部：回收阶段(销毁阶段)

当执行上下文执行完毕之后，就会被推出调用栈，此时执行上下文就会被回收

## 变量对象和活动对象

**变量对象在执行上下文的创建阶段被生成，此时变量对象不能被访问到，在执行上下文进入到执行阶段后，变量对象就会变为活动对象，此时对象中存储的变量和函数声明就可以被访问了，他们其实指向的是同一个对象，只是在执行上下文的不同阶段叫法不一样**

## 原型和原型链

**<p class="tip-color">原型</p>**

在javascript中，每一个对象都会有一个隐式的原型属性(__proto__), 指向另外一个对象，这个对象就是我们常说的原型，原型本身也是一个对象，javascript中任何对象都有原型，除了原型链的顶端对象Object.prototype， 其原型指向null， Object.prototype.__proto__ === null

```
# 获取原型对象的方法
var a = {}
Object.getPrototypeOf(a)
a.__proto__
a.constructor.prototype
```

<p class="tip-info">
    <h3>提示</h3>
    javascript中所有的对象都有原型(除了原型链顶端)，函数对象另外还有prototype属性，对象的原型指向其构造函数的prototype
</p>

**<p class="tip-color">原型链</p>**

每个对象都会有一个原型，而原型实质也是一个对象，那么它也会有原型，这样一层一层的指向就形成了原型链

**<p class="tip-color">Function 和 Object</p>**

Function和Object是javascript两个比较特别的对象，他们既是对象，也是构造函数，我们一直说Object是所有对象的基类，但对于Function来说不适用，

<p class="tip-info">Function是所有函数（构造函数）的基类，都是由Function构造而来</p>

```
Function.__proto__ === Function.prototype // Function是由自己构造而来
Object.__proto__ === Function.prototype // Object也是由Function构造而来
Function.prototype.__proto__ === Object.prototype
```

## 作用域和作用域链

**<p class="tip-color">作用域</p>**

作用域可以分为：全局作用域，函数作用域，eval作用域以及es6中的块级作用域

作用域就是当前代码执行环境可以访问到变量的权限，外层作用域不能访问里层的，里层的可以访问到外层的

**<p class="tip-color">作用域链</p>**

作用域链和原型链比较类似，每个函数都会产生对应的作用域，函数嵌套的函数也会产生其作用域，里层函数的执行环境可以访问外出函数中的变量（外层的函数不能访问里层函数的变量对象），这样一层一层的嵌套，就形成了作用域链

**<p class="tip-color">概念</p>**

javascript中的函数采用的是静态作用域，也就是词法作用域，当在执行函数调用时，不管何时何地执行代码，其中的变量在函数定义时就已经决定了，函数会从自身的作用域节点开始，沿着作用域链向上访问变量的值，直到找不到返回undefined

<p class="tip-info">
    <h3>注意</h3>
    作用域链的顶端是全局作用域，作用域链在函数定义时就已经创建了
</p>

## 闭包

**<p class="tip-color">概念</p>**

说到闭包，必定是跟函数有关，有权访问另一个函数作用域内变量的函数就可以用称之为闭包

**<p class="tip-color">特性</p>**

+ 函数返回嵌套的函数形成闭包

+ 闭包内部可以访问外部的参数和变量

+ 外部的参数和变量在被闭包引用是不会被垃圾回收机制回收，可以长期保存在内存中

**<p class="tip-color">优点</p>**

+ 可以避免变量的全局污染

+ 允许函数是有变量的存在

+ 允许变量长期存在内存中


**<p class="tip-color">缺点</p>**

由于变量没有变释放，可能会造成内存泄漏

## 垃圾回收机制

javascript中的垃圾回收采用的是自动垃圾回收机制，主要是一种针对程序执行环境中内存的管理机制，就是利用垃圾收集器，周期性的回收那些程序中，不被其他引用所指向的变量的内存资源，具体来说就是程序中不会再用到的变量，也就是生命周期结束的变量（这种变量多为局部变量），执行上下文执行完之后，其所创建的变量对象已经没有作用，就会被回收（闭包除外），全局变量都不会被回收，只有在关闭浏览器时才会被释放，所有尽量的少定义全局变量

## this的指向



## javascript事件轮询

## 继承

## 类和模块

## 同步和异步

## 事件模型 